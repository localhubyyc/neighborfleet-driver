// =====================================================
// NeighborFleet WhatsApp Send Message Edge Function
// Sends messages via Meta WhatsApp Business API
//
// FILE LOCATION: supabase/functions/whatsapp-send/index.ts
// =====================================================

import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

// Environment variables
const WHATSAPP_ACCESS_TOKEN = Deno.env.get("WHATSAPP_ACCESS_TOKEN") || "";
const WHATSAPP_PHONE_NUMBER_ID = Deno.env.get("WHATSAPP_PHONE_NUMBER_ID") || "";
const SUPABASE_URL = Deno.env.get("SUPABASE_URL") || "";
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") || "";

const WHATSAPP_API_URL = `https://graph.facebook.com/v18.0/${WHATSAPP_PHONE_NUMBER_ID}/messages`;

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

// =====================================================
// Type Definitions
// =====================================================
interface SendTextMessageRequest {
  type: "text";
  to: string;
  message: string;
  previewUrl?: boolean;
}

interface SendTemplateMessageRequest {
  type: "template";
  to: string;
  templateName: string;
  templateParams?: string[];
  language?: string;
}

interface SendInteractiveMessageRequest {
  type: "interactive";
  to: string;
  interactiveType: "button" | "list";
  header?: string;
  body: string;
  footer?: string;
  buttons?: Array<{ id: string; title: string }>;
  sections?: Array<{ title: string; rows: Array<{ id: string; title: string; description?: string }> }>;
}

type SendMessageRequest = SendTextMessageRequest | SendTemplateMessageRequest | SendInteractiveMessageRequest;

// =====================================================
// Main Handler
// =====================================================
serve(async (req: Request) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  if (req.method !== "POST") {
    return new Response("Method not allowed", { status: 405, headers: corsHeaders });
  }

  try {
    const request: SendMessageRequest = await req.json();
    
    // Validate required fields
    if (!request.to) {
      return new Response(
        JSON.stringify({ error: "Missing 'to' phone number" }),
        { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    // Check if user is opted in
    const isOptedIn = await checkOptInStatus(request.to);
    if (!isOptedIn) {
      return new Response(
        JSON.stringify({ error: "Recipient has not opted in to WhatsApp messages" }),
        { status: 403, headers: { ...corsHeaders, "Content-Type": "application/json" } }
      );
    }

    let result;
    switch (request.type) {
      case "text":
        result = await sendTextMessage(request);
        break;
      case "template":
        result = await sendTemplateMessage(request);
        break;
      case "interactive":
        result = await sendInteractiveMessage(request);
        break;
      default:
        return new Response(
          JSON.stringify({ error: "Invalid message type" }),
          { status: 400, headers: { ...corsHeaders, "Content-Type": "application/json" } }
        );
    }

    return new Response(
      JSON.stringify(result),
      { status: 200, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error) {
    console.error("Send message error:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});

// =====================================================
// Check Opt-In Status
// =====================================================
async function checkOptInStatus(phoneNumber: string): Promise<boolean> {
  const normalizedPhone = phoneNumber.replace(/[^\d+]/g, "");
  
  // Check if conversation is blocked
  const { data: conversation } = await supabase
    .from("whatsapp_conversations")
    .select("status")
    .eq("phone_number", normalizedPhone)
    .single();

  if (conversation?.status === "blocked") {
    return false;
  }

  // Check driver preferences
  const { data: prefs } = await supabase
    .from("driver_notification_preferences")
    .select("whatsapp_opted_in")
    .eq("whatsapp_phone", normalizedPhone)
    .single();

  // If no preferences found, assume opted in (new user within 24-hour window)
  return prefs?.whatsapp_opted_in !== false;
}

// =====================================================
// Send Text Message
// =====================================================
async function sendTextMessage(request: SendTextMessageRequest) {
  const payload = {
    messaging_product: "whatsapp",
    recipient_type: "individual",
    to: request.to,
    type: "text",
    text: {
      preview_url: request.previewUrl || false,
      body: request.message,
    },
  };

  return await sendToWhatsApp(payload, request.to, "text", request.message);
}

// =====================================================
// Send Template Message
// =====================================================
async function sendTemplateMessage(request: SendTemplateMessageRequest) {
  const components: any[] = [];
  
  if (request.templateParams && request.templateParams.length > 0) {
    components.push({
      type: "body",
      parameters: request.templateParams.map((param) => ({
        type: "text",
        text: param,
      })),
    });
  }

  const payload = {
    messaging_product: "whatsapp",
    recipient_type: "individual",
    to: request.to,
    type: "template",
    template: {
      name: request.templateName,
      language: {
        code: request.language || "en",
      },
      components: components.length > 0 ? components : undefined,
    },
  };

  return await sendToWhatsApp(
    payload,
    request.to,
    "template",
    null,
    request.templateName,
    request.templateParams
  );
}

// =====================================================
// Send Interactive Message (Buttons or Lists)
// =====================================================
async function sendInteractiveMessage(request: SendInteractiveMessageRequest) {
  let interactive: any;

  if (request.interactiveType === "button") {
    interactive = {
      type: "button",
      body: { text: request.body },
      action: {
        buttons: request.buttons?.slice(0, 3).map((btn) => ({
          type: "reply",
          reply: { id: btn.id, title: btn.title.slice(0, 20) },
        })),
      },
    };
  } else if (request.interactiveType === "list") {
    interactive = {
      type: "list",
      body: { text: request.body },
      action: {
        button: "Options",
        sections: request.sections,
      },
    };
  }

  if (request.header) {
    interactive.header = { type: "text", text: request.header };
  }
  if (request.footer) {
    interactive.footer = { text: request.footer };
  }

  const payload = {
    messaging_product: "whatsapp",
    recipient_type: "individual",
    to: request.to,
    type: "interactive",
    interactive,
  };

  return await sendToWhatsApp(payload, request.to, "interactive", request.body);
}

// =====================================================
// Send to WhatsApp API & Store in Database
// =====================================================
async function sendToWhatsApp(
  payload: any,
  to: string,
  messageType: string,
  content: string | null,
  templateName?: string,
  templateParams?: string[]
) {
  console.log("Sending to WhatsApp:", { to, messageType, templateName });

  // Get or create conversation
  const conversation = await getOrCreateConversation(to);

  // Send to WhatsApp API
  const response = await fetch(WHATSAPP_API_URL, {
    method: "POST",
    headers: {
      "Authorization": `Bearer ${WHATSAPP_ACCESS_TOKEN}`,
      "Content-Type": "application/json",
    },
    body: JSON.stringify(payload),
  });

  const responseData = await response.json();

  if (!response.ok) {
    console.error("WhatsApp API error:", responseData);
    
    // Store failed message
    await supabase.from("whatsapp_messages").insert({
      conversation_id: conversation?.id,
      direction: "outbound",
      message_type: messageType,
      content,
      template_name: templateName,
      template_params: templateParams ? { params: templateParams } : null,
      status: "failed",
      error_code: responseData.error?.code?.toString(),
      error_message: responseData.error?.message,
    });

    throw new Error(responseData.error?.message || "Failed to send message");
  }

  const messageId = responseData.messages?.[0]?.id;
  console.log("Message sent successfully:", messageId);

  // Store successful message
  await supabase.from("whatsapp_messages").insert({
    conversation_id: conversation?.id,
    whatsapp_message_id: messageId,
    direction: "outbound",
    message_type: messageType,
    content,
    template_name: templateName,
    template_params: templateParams ? { params: templateParams } : null,
    status: "sent",
  });

  // Update conversation
  if (conversation) {
    await supabase
      .from("whatsapp_conversations")
      .update({ last_message_at: new Date().toISOString() })
      .eq("id", conversation.id);
  }

  return {
    success: true,
    messageId,
    to,
  };
}

// =====================================================
// Get or Create Conversation
// =====================================================
async function getOrCreateConversation(phoneNumber: string) {
  const normalizedPhone = phoneNumber.replace(/[^\d+]/g, "");

  const { data: existing } = await supabase
    .from("whatsapp_conversations")
    .select("*")
    .eq("phone_number", normalizedPhone)
    .eq("status", "active")
    .single();

  if (existing) return existing;

  const { data: newConversation } = await supabase
    .from("whatsapp_conversations")
    .insert({
      phone_number: normalizedPhone,
      status: "active",
      last_message_at: new Date().toISOString(),
    })
    .select()
    .single();

  return newConversation;
}
